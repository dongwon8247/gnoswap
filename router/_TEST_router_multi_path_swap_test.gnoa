package router

import (
	"encoding/gjson"
	"std"
	"testing"

	"gno.land/p/demo/testutils"

	_ "gno.land/r/grc20_wrapper"
	p "gno.land/r/pool"
	pos "gno.land/r/position"

	"gno.land/r/bar"
	"gno.land/r/qux"
	"gno.land/r/wugnot"
)

var (
	pc01 = testutils.TestAddress("pc01") // Pool Creator 01
	lp01 = testutils.TestAddress("lp01") // Liquidity Provider 01
	tr01 = testutils.TestAddress("tr01") // Trader 01

	poolAddr   = std.DerivePkgAddr("gno.land/r/pool")
	posAddr    = std.DerivePkgAddr("gno.land/r/position")
	routerAddr = std.DerivePkgAddr("gno.land/r/router")
)

var (
	// Common
	wugnotPath = "gno.land/r/wugnot" // token1
	barPath    = "gno.land/r/bar"    // token2
	bazPath    = "gno.land/r/baz"    // token3
	quxPath    = "gno.land/r/qux"    // token4

	test_fee100 = uint16(100)
	test_fee500 = uint16(500)

	max_timeout = bigint(9999999999)
)

// func init() {
// 	println(pc01, "// pc01")
// 	println(lp01, "// lp01")
// 	println(tr01, "// tr01")
// 	println(poolAddr, "// poolAddr")
// 	println(posAddr, "// posAddr")
// 	println(routerAddr, "// routerAddr")
// }

func TestInitManual(t *testing.T) {
	std.TestSetOrigCaller(pc01)
	p.InitManual()
	std.TestSkipHeights(1)
}

func TestCreatePool(t *testing.T) {
	std.TestSetOrigCaller(pc01)

	p.CreatePool(wugnotPath, barPath, test_fee100, 130621891405341611593710811006) // tick = 10_000, ratio = 2.7181459268252253
	p.CreatePool(barPath, quxPath, test_fee100, 130621891405341611593710811006)    // tick = 10_000, ratio = 2.7181459268252253

	p.CreatePool(wugnotPath, barPath, test_fee500, 101729702841318637793976746270) // tick =  5_000, ratio = 1.648680055931176
	p.CreatePool(barPath, quxPath, test_fee500, 101729702841318637793976746270)    // tick =  5_000, ratio = 1.648680055931176
	// findSwapPaths("gno.land/r/wugnot", "gno.land/r/qux")                           // 2 paths
	// wugnot_qux_100

	jsonOutput := p.ApiGetPools()
	jsonStr := gjson.Parse(jsonOutput)
	shouldEQ(t, len(jsonStr.Get("response.data").Array()), 4)
}

func TestPositionMint(t *testing.T) {
	std.TestSetOrigCaller(lp01)
	// prepare ugnot
	testBanker := std.GetBanker(std.BankerTypeRealmIssue)
	testBanker.IssueCoin(std.GetOrigCaller(), "ugnot", 20000001)

	{
		oldWugnotBalance := wugnot.BalanceOf(a2u(poolAddr))
		oldBarBalance := bar.BalanceOf(a2u(poolAddr))
		shouldEQ(t, oldWugnotBalance, 0)
		shouldEQ(t, oldBarBalance, 0)

		// simulate transfer & decrase
		std.TestSetOrigSend(std.Coins{{"ugnot", 10000000}}, nil)
		testBanker.RemoveCoin(std.GetOrigCaller(), "ugnot", 10000000)
		tokenId, liquidity, amount0, amount1 := pos.Mint(wugnotPath, barPath, test_fee100, int32(9000), int32(11000), bigint(10000000), bigint(10000000), 0, 0, max_timeout)

		shouldEQ(t, tokenId, 1)
		shouldNEQ(t, liquidity, bigint(0))
		shouldNEQ(t, amount0, bigint(0))
		shouldNEQ(t, amount1, bigint(0))

		newWugnotBalance := wugnot.BalanceOf(a2u(poolAddr))
		newBarBalance := bar.BalanceOf(a2u(poolAddr))
		shouldEQ(t, newBarBalance, uint64(amount0))    // 3678978
		shouldEQ(t, newWugnotBalance, uint64(amount1)) // 9999999
	}

	{
		oldBarBalance := bar.BalanceOf(a2u(poolAddr))
		oldQuxBalance := qux.BalanceOf(a2u(poolAddr))
		shouldEQ(t, oldBarBalance, 3678978)
		shouldEQ(t, oldQuxBalance, 0)

		tokenId, liquidity, amount0, amount1 := pos.Mint(barPath, quxPath, test_fee100, int32(9000), int32(11000), bigint(10000000), bigint(10000000), 0, 0, max_timeout)
		shouldEQ(t, tokenId, 2)
		shouldNEQ(t, liquidity, bigint(0))
		shouldNEQ(t, amount0, bigint(0))
		shouldNEQ(t, amount1, bigint(0))

		newBarBalance := bar.BalanceOf(a2u(poolAddr))
		newQuxBalance := qux.BalanceOf(a2u(poolAddr))
		shouldEQ(t, newBarBalance, uint64(amount0)+3678978) // 7357956
		shouldEQ(t, newQuxBalance, uint64(amount1))         // 9999999
	}

	{
		oldWugnotBalance := wugnot.BalanceOf(a2u(poolAddr))
		oldBarBalance := bar.BalanceOf(a2u(poolAddr))
		shouldEQ(t, oldWugnotBalance, 9999999)
		shouldEQ(t, oldBarBalance, 7357956)

		// simulate transfer & decrase
		std.TestSetOrigSend(std.Coins{{"ugnot", 10000000}}, nil)
		testBanker.RemoveCoin(std.GetOrigCaller(), "ugnot", 10000000)
		tokenId, liquidity, amount0, amount1 := pos.Mint(wugnotPath, barPath, test_fee500, int32(4000), int32(6000), bigint(10000000), bigint(10000000), 0, 0, max_timeout)

		shouldEQ(t, tokenId, 3)
		shouldNEQ(t, liquidity, bigint(0))
		shouldNEQ(t, amount0, bigint(0))
		shouldNEQ(t, amount1, bigint(0))

		newWugnotBalance := wugnot.BalanceOf(a2u(poolAddr))
		newBarBalance := bar.BalanceOf(a2u(poolAddr))
		shouldEQ(t, newBarBalance, uint64(amount0)+7357956)    // 13423414
		shouldEQ(t, newWugnotBalance, uint64(amount1)+9999999) // 19999998
	}

	{
		oldBarBalance := bar.BalanceOf(a2u(poolAddr))
		oldQuxBalance := qux.BalanceOf(a2u(poolAddr))
		shouldEQ(t, oldBarBalance, 13423414)
		shouldEQ(t, oldQuxBalance, 9999999)

		tokenId, liquidity, amount0, amount1 := pos.Mint(barPath, quxPath, test_fee500, int32(4000), int32(6000), bigint(10000000), bigint(10000000), 0, 0, max_timeout)
		shouldEQ(t, tokenId, 4)
		shouldNEQ(t, liquidity, bigint(0))
		shouldNEQ(t, amount0, bigint(0))
		shouldNEQ(t, amount1, bigint(0))

		newBarBalance := bar.BalanceOf(a2u(poolAddr))
		newQuxBalance := qux.BalanceOf(a2u(poolAddr))
		shouldEQ(t, newBarBalance, uint64(amount0)+13423414) // 19488872
		shouldEQ(t, newQuxBalance, uint64(amount1)+9999999)  // 19999998
	}
}

func TestBestSwapExactInMultiPath(t *testing.T) {
	std.TestSetOrigCaller(tr01)
	// prepare ugnot
	testBanker := std.GetBanker(std.BankerTypeRealmIssue)
	testBanker.IssueCoin(std.GetOrigCaller(), "ugnot", 20000001)

	userOldWugnotBalance := wugnot.BalanceOf(a2u(tr01))
	userOldQuxBalance := qux.BalanceOf(a2u(tr01))
	poolOldWugnotBalance := wugnot.BalanceOf(a2u(poolAddr))
	poolOldQuxBalance := qux.BalanceOf(a2u(poolAddr))

	swapAmount := int64(123_456)
	std.TestSetOrigSend(std.Coins{{"ugnot", swapAmount}}, nil)
	testBanker.RemoveCoin(std.GetOrigCaller(), "ugnot", swapAmount)

	BestSwap(
		wugnotPath,         // inputToken
		quxPath,            // outputToken
		"EXACT_IN",         // swapType
		bigint(swapAmount), // amountSpecified
		0,                  // sqrtPriceLimitX96
		5,                  // distributionPercent
		10,                 // maxRoutes
		5,                  // maxHops
	)

	userNewWugnotBalance := wugnot.BalanceOf(a2u(tr01))
	userNewQuxBalance := qux.BalanceOf(a2u(tr01))
	poolNewWugnotBalance := wugnot.BalanceOf(a2u(poolAddr))
	poolNewQuxBalance := qux.BalanceOf(a2u(poolAddr))

	shouldEQ(t, userOldWugnotBalance, 0)
	shouldEQ(t, userOldWugnotBalance, userNewWugnotBalance)

	shouldGT(t, userNewQuxBalance, userOldQuxBalance)

	shouldEQ(t, poolNewWugnotBalance-poolOldWugnotBalance, 123456) // user ugnot => WRAPPED
	shouldGT(t, poolOldQuxBalance, poolNewQuxBalance)
}

func TestBestSwapExactOutMultiPath(t *testing.T) {
	std.TestSetOrigCaller(tr01)
	// prepare ugnot
	testBanker := std.GetBanker(std.BankerTypeRealmIssue)
	testBanker.IssueCoin(std.GetOrigCaller(), "ugnot", 500_000_000)

	userOldWugnotBalance := wugnot.BalanceOf(a2u(tr01))
	userOldQuxBalance := qux.BalanceOf(a2u(tr01))
	poolOldWugnotBalance := wugnot.BalanceOf(a2u(poolAddr))
	poolOldQuxBalance := qux.BalanceOf(a2u(poolAddr))

	std.TestSetOrigSend(std.Coins{{"ugnot", 366350}}, nil)
	testBanker.RemoveCoin(std.GetOrigCaller(), "ugnot", 366350)

	swapAmount := 987_654
	BestSwap(
		wugnotPath,         // inputToken
		quxPath,            // outputToken
		"EXACT_OUT",        // swapType
		bigint(swapAmount), // amountSpecified
		0,                  // sqrtPriceLimitX96
		5,                  // distributionPercent
		10,                 // maxRoutes
		5,                  // maxHops
	)

	userNewWugnotBalance := wugnot.BalanceOf(a2u(tr01))
	userNewQuxBalance := qux.BalanceOf(a2u(tr01))
	poolNewWugnotBalance := wugnot.BalanceOf(a2u(poolAddr))
	poolNewQuxBalance := qux.BalanceOf(a2u(poolAddr))

	shouldEQ(t, poolOldQuxBalance-987654, poolNewQuxBalance)
}

/* HELPER */
func shouldEQ(t *testing.T, got, expected interface{}) {
	if got != expected {
		t.Errorf("got %v, expected %v", got, expected)
	}
}

func shouldNEQ(t *testing.T, got, expected interface{}) {
	if got == expected {
		t.Errorf("got %v, didn't expected %v", got, expected)
	}
}

func shouldGT(t *testing.T, l, r interface{}) {
	if !(l > r) {
		t.Errorf("expected %v > %v", l, r)
	}
}

func shouldGTE(t *testing.T, l, r interface{}) {
	if !(l >= r) {
		t.Errorf("expected %v > %v", l, r)
	}
}

func shouldLT(t *testing.T, l, r interface{}) {
	if !(l < r) {
		t.Errorf("expected %v < %v", l, r)
	}
}

func shouldLTE(t *testing.T, l, r interface{}) {
	if !(l <= r) {
		t.Errorf("expected %v < %v", l, r)
	}
}

func ugnotBalance(addr std.Address) std.Coin {
	testBanker := std.GetBanker(std.BankerTypeRealmIssue)
	coins := testBanker.GetCoins(tr01)

	if len(coins) == 0 {
		return nil
	}

	if len(coins) == 1 {
		coin := coins[0]
		return coin
	}
}
